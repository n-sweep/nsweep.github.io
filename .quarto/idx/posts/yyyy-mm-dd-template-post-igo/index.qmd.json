{"title":"Go in Python, Part 3","markdown":{"yaml":{"title":"Go in Python, Part 3","description":"This Is Still Not An Article About Golang","author":"n sweep","date":"yyyy-mm-dd","categories":["go","baduk","python","programming"],"draft":true},"headingText":"ReCap","containsRefs":false,"markdown":"\n\nRead: [Go in Python, Part 2](https://sweep.sh/posts/2024-10-28-go-in-python-2/)\n\nTODO: image\n\n\nLast time, we parsed a Smart Game Format (SGF) file and played some stones on our `Board` object. Let's take a look at the latter for now:\n\n```py\nimport numpy as np\nimport re\nfrom itertools import product\n\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\nSP = \"╺╸\"\n\nBLACK = '\\033[30m' #]\nGRAY = '\\033[90m' #]\nYELLOW = '\\033[33m' #]\nBG_YELLOW = '\\033[43m' #]\nRESET = '\\033[0m' #]\n\n\nclass Board:\n    \"\"\"Representation of a Go board\n\n    Parameters\n    ----------\n    size : int\n        The size of the board dictates the length and width\n        Typically 9, 13, or 19\n\n    Attributes\n    ----------\n    size : int\n        The size of the board dictates the length and width\n        Typically 9, 13, or 19\n    state : np.array\n        State of the current board represented in integers\n        0 = empty space, 1 = black stone, 2 = white stone\n    \"\"\"\n\n    def __init__(self, size: int) -> None:\n        self.size = size\n        self.state = np.zeros((size,size))\n        self.move = 0\n\n    def play(self, player: int, x: int, y: int) -> None:\n        \"\"\"Play a stone on the board\n\n        Parameters\n        ----------\n        player\n            1 for black, 2 for white\n        x\n            The column on which to play\n        y\n            The row on which to play\n        \"\"\"\n\n        self.state[y, x] = player\n        self.move += 1\n\n    def plaintext_board(self) -> str:\n        \"\"\"Create a terminal-printable plain text board, including colors\n\n        Returns\n        -------\n        Plain text representation of the current board state\n        \"\"\"\n\n        star_points = np.zeros((self.size,self.size), dtype=int)\n        corners = [j for i in range(3) if (j:=((s:=2+(self.size>9))+(2*s*i))) < self.size]\n        pts = [(f:=self.size//2, f)] + list(product(corners, repeat=2))\n        star_points[*zip(*pts)] = -1\n\n        board = self.state.copy()\n        mask = ~self.state.astype(bool)\n        board[mask] = star_points[mask]\n\n        joined = ' '.join(list(ALPHA.replace('i', '')[:self.size])).upper()\n        rows = [col_label:=f\"{YELLOW}{(d:='-' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\n        for r, input_row in enumerate(board, 1):\n            row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n            num = str(self.size - r + 1)\n            lnum = num.rjust(int(len(str(self.size))))\n            rnum = num.ljust(int(len(str(self.size))))\n            rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\n        rows.append(col_label)\n        rows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\n        return '\\n'.join(rows)\n\n    def __str__(self) -> str:\n        return self.plaintext_board()\n```\n\n## ~~Re~~Capturing\n\nTo demonstrate the next problem, I've created a predetermined list of moves. We'll play each stone from the list, printing the board and pausing for 1 second in between:\n\n```py\nfrom time import sleep\n\nmoves = [\n    (1, 3, 4), (2, 4, 4),\n    (1, 4, 3), (2, 5, 3),\n    (1, 4, 5), (2, 5, 5),\n    (1, 5, 4)\n]\n\nb = Board(9)\nfor player, x, y in moves:\n    b.play(player, x, y)\n    sleep(1)\n    print(b)\n```\n\n<img src='./images/demo1.gif' />\n\nIf you're familiar with the game, you'll see a problem here: when black plays their 4th stone, white's first play at **E5** should be captured and removed from the board. Not only that, but *groups* of stones that are surrounded in a similar manner are also captured. See this quick demonstration done on [OGS](https://online-go.com) in which captures stones are properly removed from the board:\n\n::: {.callout-note collapse=\"true\"}\n## Working Capturing Example\n<figure>\n    <img src='./images/demo2.gif' width=600 />\n    <figcaption><i><strong>Note: This gif does not depict a real game</strong>; specifically, in the second part I place stones out of order only to demonstrate a capturing move.</i></figcaption>\n</figure>\n:::\n\n## Let's Go\n\nToday's goal is to **identify groups of 1 or more stones to determine if a given group has been surrounded/captured**.\n\n::: {.callout-note collapse=\"true\"}\n## More on *connections* & *groups* in Go\n\n<figure>\n    <a href=\"https://en.wikipedia.org/wiki/Go_(game)#/media/File:Go_board_part.jpg\">\n        <img src='https://upload.wikimedia.org/wikipedia/commons/8/80/Go_board_part.jpg' width=200 />\n    </a>\n    <figcaption style=\"font-size: 12px;\"><i>Wikipedia</i></figcaption>\n</figure>\n\nA **group** is a series of stones which are **connected** to one another.\n\nOur board is unable to represent this due to the constraints of monospace text and the size of emoji characters, but a true Go board has lines, creating intersections on which the stones are played. Two stones are **connected** if they occupy intersections immediately next to one another connected by a line - this means orthogonal stones only, diagonals do not count as connections.\n\nIn the image above we can see one group of two and one group of 3 for black and one group of three for white, as well as a single stone for each.\n:::\n\nWe need a board to work with, so let's set up the second situation from the working capturing example above where white has a group of four stones in atari (one move away from capture):\n\n```py\nb = Board(9)\nmoves = [\n    (2, 3, 4), (2, 4, 3), (2, 4, 4), (2, 4, 5),\n    (1, 5, 3), (1, 5, 4), (1, 5, 5), (1, 4, 2),\n    (1, 4, 6), (1, 3, 3), (1, 3, 5)\n]\n\nfor player, x, y in moves:\n    b.play(player, x, y)\n\nprint(b)\n```\n\n<img src='./images/atari1.png' />\n\n# Neighbors And Groups\n\nAs I mentioned above, white's group is **in atari**, or one move by black (C5) away from capture. Another way to say this is that white's group has only one **liberty** left. **Liberties** are vacant intersections adjacent (again, orthogonal only) to a group.\n\nTo determine if a group is captured, we must know how many liberties a group has (0: captured, >0: uncaptured). To determine the liberties of a group, we must know 1. each stone in the group, and 2. the liberties of each of those stones. To find a stone's connections and liberties, we must know about its neighbors.\n\n## Representing The Stone\n\nWe are storing the state of the game in an array where stones are represented by integers:\n\n```py\nb.state\n```\n```\narray([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 1, 2, 1, 0, 0, 0],\n       [0, 0, 0, 2, 2, 1, 0, 0, 0],\n       [0, 0, 0, 1, 2, 1, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n```\n\nKnowing that every stone is greater than zero, we can get the location of each stone on the board based on the board state:\n\n```py\nfor i, j in list(zip(*np.where(b.state > 0))):\n    print(b.state[i, j], (i, j))\n```\n```\n1 (2, 4)\n1 (3, 3)\n2 (3, 4)\n1 (3, 5)\n2 (4, 3)\n2 (4, 4)\n1 (4, 5)\n1 (5, 3)\n2 (5, 4)\n1 (5, 5)\n1 (6, 4)\n```\n\nStarting with the first stone in the list, we only care about the orthogonal locations:\n\n```py\nlocation = np.array((2, 4))\nneighbor_locs = np.array(((0, 1), (1, 0), (0, -1), (-1, 0))) + location\n```\n\nThe stones in our example are safe, but we have to account for stones along the edges which would have neighboring spaces outside the bounds of the board:\n\n```py\noob = (neighbor_locs < 0) | (neighbor_locs >= b.size)\nneighbor_locs = neighbor_locs[~oob.any(axis=1)]\nneighbor_vals = b.state[neighbor_locs[:, 0], neighbor_locs[:, 1]]\n```\n\nWith this information we can retrieve the value of each neighbor, which will tell us if it is a connection with a friendly or enemy stone, or an open liberty.\n\nThis stone has three liberties:\n\n```py\nneighbor_locs[neighbor_vals < 1]\n```\n```\narray([[2, 5],\n       [2, 3],\n       [1, 4]])\n```\n\nAnd zero friendly connections:\n\n```py\nneighbor_locs[neighbor_vals == b.state[*location]]\n```\n```\narray([], shape=(0, 2), dtype=int64)\n```\n\nFinally, we can package this into a convenient `Stone` class:\n\n```py\nclass Stone:\n    \"\"\"Representation of a Go stone\n\n    Parameters\n    ----------\n    board : Board\n        the Board object on which the stone is played\n    color : int\n        the color/player of the stone\n        1 for black, 2 for white\n    location : np.array\n        x, y location of the stone on the board\n    \"\"\"\n\n    def __init__(self, board: Board, color: int, location: np.ndarray) -> None:\n        self.board = board\n        self.color = color  # 1 is black, 2 is white\n        self.location = location\n\n    @property\n    def neighbors(self) -> tuple:\n        \"\"\"Determines the locations and values corresponding to\n        each space neighboring this stone\n\n        Returns\n        -------\n        tuple containing an array of locations and an array of values of neighbors\n        \"\"\"\n        neighbor_locs = np.array(((0, 1), (1, 0), (0, -1), (-1, 0))) + self.location\n        oob = (neighbor_locs < 0) | (neighbor_locs >= self.board.size)\n        neighbor_locs = neighbor_locs[~oob.any(axis=1)]\n        neighbor_vals = self.board.state[neighbor_locs[:, 0], neighbor_locs[:, 1]]\n\n        return neighbor_locs, neighbor_vals\n\n    @property\n    def connections(self) -> list:\n        \"\"\"Stone's friendly connections\n\n        Returns\n        -------\n        the locations of each friendly connection on the board\n        \"\"\"\n        locs, vals = self.neighbors\n        return locs[vals == self.color]\n\n    @property\n    def liberties(self) -> set:\n        \"\"\"Stone's liberties\n\n        Returns\n        -------\n        the locations of each open liberty on the board\n        \"\"\"\n        locs, vals = self.neighbors\n        return set(map(tuple, locs[vals < 1]))\n\n    def __int__(self) -> int:\n        return self.color\n\n    def __index__(self) -> int:\n        return self.color\n\n    def __hash__(self) -> int:\n        y, x = self.location\n        return hash(f'{x}{y}')\n\n    def __gt__(self, other) -> bool:\n        return self.color > other\n\n    def __lt__(self, other) -> bool:\n        return self.color < other\n\n    def __eq__(self, other) -> bool:\n        return self.color == other\n\n    def __str__(self) -> str:\n        return f'{(B, W)[self.color-1]} {self.location}'\n\n    def __repr__(self) -> str:\n        return f'Stone(Board, {self.color}, {self.location})'\n```\n\nWith this structure, each stone can now tell us about its connections, liberties, and neighbors. We are going to begin putting `Stone` objects directly into the board's state instead of just integers. For this to work, a `Stone` has to have a few specific properties:\n\n1. The stone must behave like an integer in certain situations\n    - The integer represents which player the stone belongs to (1 or 2)\n    - This allows the stone to:\n        1. Be compared with one another to determine if the stones are friendly\n        1. Be used as a list index\n1. Each stone must be a unique (hashable) object\n    - Objects must be hashable to be used in a set, which we will need shortly for finding connected groups of stones\n    - By default, python does this with `__eq__`\n    - We are using `__eq__` for determining a stone's player/color\n    - To resolve, we must implement `__hash__`*\n\nTo this end, we'll implement a series of _magic methods_* in addition to the `.neighbors()`, `.connections()`, and `.liberties()` methods we just developed.\n\n::: {.callout-tip collapse=\"true\"}\n## *Read More About Magic Methods\n\n\"Magic methods\" are also known as *dunder* methods, for their surrounding ***d***ouble ***under***scores. If you'd like a deeper understanding of how they work, I found this wonderful guide by `rszalski` on GitHub: [rszalski.github.io/magicmethods](https://rszalski.github.io/magicmethods/)\n\nHere's the tl;dr for the ones used in our `Stone` class so far:\n\n- These methods allow our stones to behave like integers when appropriate, while still being recognized as individual stones\n    - `__int__`: determines what happens when coerced into an integer, ie: `int(Stone(...))`\n    - `__index__`: determines what happens when used as a list index, ie: `some_list[Stone(...)]`\n    - `__hash__`: allows Stone objects that are \"equal\" (ie owned by the same player) to be differentiated from one another. this makes the objects \"hashable\"\n        - the important unique information about a stone on the board is its location; we'll use each stone's `x` and `y` values to create its hash\n\n- Comparison methods allow the object to be used with logical operators (further allowing them to behave like integers)\n    - `__gt__`: greater than comparison, eg: `Stone > 1` (the stone belongs to player 2)\n    - `__lt__`: less than comparison, eg: `Stone < 2` (the stone belongs to player 1)\n    - `__eq__`: equality comparison, eg: `Stone == Stone` (stones belong to the same player)\n\n- Other commonly used methods\n    - `__init__`: runs automatically whenever a new instance of the class is created\n    - `__str__`: determines what happens when coerced into a string, ie: `str(Stone(...))` or `print(Stone(...))`\n    - `__repr__`: similar to `__str__`; read the guide above for more info!\n:::\n\nWe'll also add two new methods to the `Board` class to return our `Stone` objects (we will need to get stones by player later on), and edit the existing `.play()` method to add a stone instead of an integer to the board:\n\n```py\nclass Board:\n    ...\n    def get_stones(self, player: int|None = None) -> np.ndarray:\n        if player is not None:\n            return self.state[self.state == player]\n        return self.state[self.state > 0]\n\n    @property\n    def stones(self) -> np.ndarray:\n        return self.get_stones()\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = Stone(self, player, np.array((y, x)))\n        self.move += 1\n    ...\n```\n\nAnd then we can easily access our list of stones from the board object!\n\n```py\nb.stones\n```\n```\n[Stone(Board, 1, [2 4]),\n Stone(Board, 1, [3 3]),\n Stone(Board, 2, [3 4]),\n Stone(Board, 1, [3 5]),\n Stone(Board, 2, [4 3]),\n Stone(Board, 2, [4 4]),\n Stone(Board, 1, [4 5]),\n Stone(Board, 1, [5 3]),\n Stone(Board, 2, [5 4]),\n Stone(Board, 1, [5 5]),\n Stone(Board, 1, [6 4])]\n```\n\n## It's A Beautiful Day In The Neighborhood\n\nNow that each stone can tell us who its neighbors are, we effectively have a graph which can be recursively searched to identify groups of stones. Depth-first search is marginally simpler than breadth-first, not requiring a queue:\n\n```py\ndef recursive_find_group(stone, group=None) -> set|None:\n    group = set() if group is None else group\n    if stone in group:                          # <1>\n        return\n    group.add(stone)                            # <2>\n    for con in stone.connections:               # <3>\n        recursive_find_group(con, group)\n    return group\n```\n1. Base case: return if the stone has already been seen\n2. Add the stone to the group\n3. Repeat this process for each of the stone's connections\n\nAs we saw earlier, the stone we have been using `[2, 4]` does not have any friendly neighbors and is therefore a \"group\" of 1 stone. We can instead choose one of white's stones, `[4, 3]`, as the starting stone from which to find a larger group.\n\n```py\nstarting_stone = b.stones[4]  # white stone, located [4, 3]\nresult = recursive_find_group(starting_stone)\nprint(result)\n```\n```\n{Stone(Board, 2, [4 5]),\n Stone(Board, 2, [4 3]),\n Stone(Board, 2, [3 4]),\n Stone(Board, 2, [4 4])}\n```\n\nThese are the stones we are looking for. Now let's try to get every group on the board. There is a single white group of four stones, and 5 black groups; one with three stones, and four with one stone each. We should see six total groups:\n\n```py\ngroups = []\nstones = set(b.get_stones())\nwhile stones:\n    group = recursive_find_group(stones.pop())\n    groups.append(group)\n    stones = stones - group\n\nprint('Total # of groups:', len(groups))\n```\n```\nTotal # of groups: 6\n```\n\nPerfect!\n\n# Re: Capturing\n\nIf you recall from earlier, a stone or group of stones is captured when all of its liberties (empty adjacent spaces) are filled by the opponent. Each stone in our groups also knows about its liberties, so we can easily get the total liberties of a group.\n\nThe first group in the list we created above is the black group of 3 on the right side of the board. It should have 5 total liberties:\n\n```py\ngroup = groups[0]\nliberties = len(set.union(*[s.liberties for s in group]))\n\nprint('Total liberties:', liberties)\n```\n```\nTotal liberties: 5\n```\n\nThe third group in our list is the white group. This group has one liberty, but if we play another black stone at `2, 4` (C5) it will have zero:\n\n```py\nb.play(1, 2, 4)\n\ngroup = groups[2]\nliberties = len(set.union(*[s.liberties for s in group]))\n\nprint('Total liberties:', liberties)\n```\n```\nTotal liberties: 0\n```\n\nAt which point it should be removed from the board:\n\n```py\nif liberties == 0:\n    remove = np.array([s.location for s in group])\n    b.state[remove[:, 0], remove[:, 1]] = 0\n\nprint(b)\n```\n\n<img src='./images/capture1.png' />\n\n## Putting It Together\n\nNow we can add a new class method `.process_stones()` to the board which will remove captured groups. We'll also further edit the `.play()` method because we want to check for captured groups on each play:\n\n```py\nclass Board:\n    ...\n    def process_groups(self) -> None:\n        \"\"\"Find groups of stones and remove those with no liberties\"\"\"\n\n        def recursive_find_group(stone, group=None) -> set:\n            \"\"\"Recursively find groups of stones\n\n            Parameters\n            ----------\n            stone\n                a stone to be added to the group\n            group\n                the current group of stones\n            Returns\n            -------\n            a unique set of the stones in a group with the starting stone\n            \"\"\"\n\n            group = set() if group is None else group\n            if stone in group:\n                return set()\n            group.add(stone)\n            for con in stone.connections:\n                recursive_find_group(con, group)\n            return group\n\n        groups = []\n        stones = set(self.get_stones())\n        while stones:\n            group = recursive_find_group(stones.pop())\n            groups.append(group)\n            stones = stones - group\n\n            liberties = len(set.union(*[s.liberties for s in group]))\n            if liberties == 0:\n                remove = np.array([s.location for s in group])\n                self.state[remove[:, 0], remove[:, 1]] = 0\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = Stone(self, player, np.array((y, x)))\n        self.process_groups()\n        self.move += 1\n    ...\n```\n\nLet's take another look at our simple example from the beginning:\n\n```py\nb = Board(9, debug=True)\nplays = [\n    (1, 3, 4), (2, 4, 4),\n    (1, 4, 3), (2, 5, 3),\n    (1, 4, 5), (2, 5, 5),\n    (1, 5, 4)\n]\n\nfor player, x, y in plays:\n    b.play(player, x, y)\n    sleep(1)\n    print(b)\n```\n\n<img src='./images/successfulcapture1.gif' />\n\nBeautiful! Next, let's try to play a full game.\n\n# Playing The Game\n\nAs mentioned at the beginning, [last episode](https://sweep.sh/posts/2024-10-28-go-in-python-2/#smart-game-format) we also wrote some code to retrieve Smart Game Format game data from [OGS](https://online-go.com) and parse the results. Here, we'll turn these steps into a pair of functions:\n\n```py\nimport os\nimport requests\n\nBASE_URL = \"https://online-go.com/api/v1/games\"\n\n\ndef retrieve_sgf(game_url: str) -> str:                                 # <1>\n    \"\"\"Retrieve the SGF text from the given game url or id\n\n    Parameters\n    ----------\n    game_url\n        the url or game id of an OGS game\n\n    Returns\n    -------\n    the Smart Game Format text data for the given game\n    \"\"\"\n\n    game_id = game_url.strip(\"https://online-go.com/game/\")             # <2>\n    request_url = os.path.join(BASE_URL, game_id, 'sgf')\n\n    r = requests.get(request_url)\n    return r.content.decode('utf-8')\n\ndef read_sgf(sgf: str) -> tuple:                                        # <3>\n    \"\"\"Parse a Smart Game Format file into metadata and game moves\n\n    Parameters\n    ----------\n    sgf\n        string data of the SGF file\n\n    Returns\n    -------\n    a tuple containing metadata and game moves\n    \"\"\"\n\n    text = sgf.strip(')').split(';')\n    meta = dict(re.findall(r'(\\w+)\\[(.*?)\\]\\n?', text[1]))\n    moves = [tuple(m.strip('\\n()]').split('[')) for m in text[2:]]\n\n    return meta, moves\n```\n1. `retrieve_sgf()` gets SGF data from an OGS game. This is specific to OGS, so it is kept separate from `read_sgf()`.\n2. I want the function to be able to take a game ID or a full link to the game. Here we strip the url off of the game ID if it exists, then build an API url to make the request.\n3. `read_sgf()` parses metadata and game moves out of an SGF string. In the future, we could get SGF files from different sources, so this is kept separate from `retrieve_sgf()`\n\n```py\ngame = \"https://online-go.com/game/68039230\"\nsgf = retrieve_sgf(game)\nmeta, moves = read_sgf(sgf)\n\nsize = int(meta['SZ'])\n\nprint('Board size:', size)\nprint('# of moves:', len(moves))\nprint('Result:', meta['RE'])\nprint('\\nMoves:\\n', moves)\n```\n```\nBoard size: 13\n# of moves: 100\nResult: B+26.5\n\nMoves:\n[('B', 'gg'),\n ('W', 'kc'),\n ('B', 'ji'),\n\n ...\n\n ('W', 'cj'),\n ('B', ''),\n ('W', '')]\n```\n\nFrom the SGF, we can see that game number 68039230 was played on a 13x13 board to 100 moves. It ended with a mutual pass and Black won by 26.5 points. Let's watch:\n\n```py\nb = Board(size)\nfor player, move in moves:\n    player = 'BW'.index(player) + 1\n\n    if move:  # an empty move is a pass\n        x, y = (ALPHA.index(c) for c in move)\n\n        b.play(player, x, y)\n        print(b)\n        sleep(0.15)\n```\n<figure>\n    <img src='./images/fullgame1.gif' />\n    <figcaption><i>Result: B+26.5</i></figcaption>\n</figure>\n\n## Wrap It Up\n\nWith that, I think it would be useful to abstract the idea of getting moves from an OGS game and playing them on the board:\n\n```py\nfrom typing import Generator\n\nclass OGSGame:\n    BASE_URL = \"https://online-go.com/api/v1/games/\"\n\n    def __init__(self, game_url: str) -> None:\n        self.id = game_url.strip(\"https://online-go.com/game/\")\n        self.url = self.BASE_URL + self.id\n        self.sgf = self.retrieve_sgf()\n        self.meta, self.moves = read_sgf(self.sgf)\n        self.board = Board(int(self.meta['SZ']))\n\n    @property\n    def data(self) -> dict:\n        return requests.get(self.url).json()\n\n    @property\n    def turns(self) -> Generator:\n        yield self.board\n        for player, move in self.moves:\n            player = 'BW'.index(player) + 1\n\n            if move:\n                x, y = (ALPHA.index(c) for c in move)\n                self.board.play(player, x, y)\n\n            yield self.board\n\n    def retrieve_sgf(self) -> str:\n        text = requests.get(self.url + '/sgf').text\n        if text == 'Permission denied':\n            raise ValueError('Cannot access private game')\n\n        return text\n```\n```\n\n```\n\nIt's probably unnecessary to make `turns` a generator, but it's probably also unnecessary to have the `Board` object render itself. A problem(s) for another day. :)\n\n\n- Part 4?\n    - vhs\n        - nixos\n        - docker\n    - plotly\n    - discord\n    - docker\n","srcMarkdownNoYaml":"\n\nRead: [Go in Python, Part 2](https://sweep.sh/posts/2024-10-28-go-in-python-2/)\n\nTODO: image\n\n# ReCap\n\nLast time, we parsed a Smart Game Format (SGF) file and played some stones on our `Board` object. Let's take a look at the latter for now:\n\n```py\nimport numpy as np\nimport re\nfrom itertools import product\n\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\nSP = \"╺╸\"\n\nBLACK = '\\033[30m' #]\nGRAY = '\\033[90m' #]\nYELLOW = '\\033[33m' #]\nBG_YELLOW = '\\033[43m' #]\nRESET = '\\033[0m' #]\n\n\nclass Board:\n    \"\"\"Representation of a Go board\n\n    Parameters\n    ----------\n    size : int\n        The size of the board dictates the length and width\n        Typically 9, 13, or 19\n\n    Attributes\n    ----------\n    size : int\n        The size of the board dictates the length and width\n        Typically 9, 13, or 19\n    state : np.array\n        State of the current board represented in integers\n        0 = empty space, 1 = black stone, 2 = white stone\n    \"\"\"\n\n    def __init__(self, size: int) -> None:\n        self.size = size\n        self.state = np.zeros((size,size))\n        self.move = 0\n\n    def play(self, player: int, x: int, y: int) -> None:\n        \"\"\"Play a stone on the board\n\n        Parameters\n        ----------\n        player\n            1 for black, 2 for white\n        x\n            The column on which to play\n        y\n            The row on which to play\n        \"\"\"\n\n        self.state[y, x] = player\n        self.move += 1\n\n    def plaintext_board(self) -> str:\n        \"\"\"Create a terminal-printable plain text board, including colors\n\n        Returns\n        -------\n        Plain text representation of the current board state\n        \"\"\"\n\n        star_points = np.zeros((self.size,self.size), dtype=int)\n        corners = [j for i in range(3) if (j:=((s:=2+(self.size>9))+(2*s*i))) < self.size]\n        pts = [(f:=self.size//2, f)] + list(product(corners, repeat=2))\n        star_points[*zip(*pts)] = -1\n\n        board = self.state.copy()\n        mask = ~self.state.astype(bool)\n        board[mask] = star_points[mask]\n\n        joined = ' '.join(list(ALPHA.replace('i', '')[:self.size])).upper()\n        rows = [col_label:=f\"{YELLOW}{(d:='-' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\n        for r, input_row in enumerate(board, 1):\n            row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n            num = str(self.size - r + 1)\n            lnum = num.rjust(int(len(str(self.size))))\n            rnum = num.ljust(int(len(str(self.size))))\n            rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\n        rows.append(col_label)\n        rows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\n        return '\\n'.join(rows)\n\n    def __str__(self) -> str:\n        return self.plaintext_board()\n```\n\n## ~~Re~~Capturing\n\nTo demonstrate the next problem, I've created a predetermined list of moves. We'll play each stone from the list, printing the board and pausing for 1 second in between:\n\n```py\nfrom time import sleep\n\nmoves = [\n    (1, 3, 4), (2, 4, 4),\n    (1, 4, 3), (2, 5, 3),\n    (1, 4, 5), (2, 5, 5),\n    (1, 5, 4)\n]\n\nb = Board(9)\nfor player, x, y in moves:\n    b.play(player, x, y)\n    sleep(1)\n    print(b)\n```\n\n<img src='./images/demo1.gif' />\n\nIf you're familiar with the game, you'll see a problem here: when black plays their 4th stone, white's first play at **E5** should be captured and removed from the board. Not only that, but *groups* of stones that are surrounded in a similar manner are also captured. See this quick demonstration done on [OGS](https://online-go.com) in which captures stones are properly removed from the board:\n\n::: {.callout-note collapse=\"true\"}\n## Working Capturing Example\n<figure>\n    <img src='./images/demo2.gif' width=600 />\n    <figcaption><i><strong>Note: This gif does not depict a real game</strong>; specifically, in the second part I place stones out of order only to demonstrate a capturing move.</i></figcaption>\n</figure>\n:::\n\n## Let's Go\n\nToday's goal is to **identify groups of 1 or more stones to determine if a given group has been surrounded/captured**.\n\n::: {.callout-note collapse=\"true\"}\n## More on *connections* & *groups* in Go\n\n<figure>\n    <a href=\"https://en.wikipedia.org/wiki/Go_(game)#/media/File:Go_board_part.jpg\">\n        <img src='https://upload.wikimedia.org/wikipedia/commons/8/80/Go_board_part.jpg' width=200 />\n    </a>\n    <figcaption style=\"font-size: 12px;\"><i>Wikipedia</i></figcaption>\n</figure>\n\nA **group** is a series of stones which are **connected** to one another.\n\nOur board is unable to represent this due to the constraints of monospace text and the size of emoji characters, but a true Go board has lines, creating intersections on which the stones are played. Two stones are **connected** if they occupy intersections immediately next to one another connected by a line - this means orthogonal stones only, diagonals do not count as connections.\n\nIn the image above we can see one group of two and one group of 3 for black and one group of three for white, as well as a single stone for each.\n:::\n\nWe need a board to work with, so let's set up the second situation from the working capturing example above where white has a group of four stones in atari (one move away from capture):\n\n```py\nb = Board(9)\nmoves = [\n    (2, 3, 4), (2, 4, 3), (2, 4, 4), (2, 4, 5),\n    (1, 5, 3), (1, 5, 4), (1, 5, 5), (1, 4, 2),\n    (1, 4, 6), (1, 3, 3), (1, 3, 5)\n]\n\nfor player, x, y in moves:\n    b.play(player, x, y)\n\nprint(b)\n```\n\n<img src='./images/atari1.png' />\n\n# Neighbors And Groups\n\nAs I mentioned above, white's group is **in atari**, or one move by black (C5) away from capture. Another way to say this is that white's group has only one **liberty** left. **Liberties** are vacant intersections adjacent (again, orthogonal only) to a group.\n\nTo determine if a group is captured, we must know how many liberties a group has (0: captured, >0: uncaptured). To determine the liberties of a group, we must know 1. each stone in the group, and 2. the liberties of each of those stones. To find a stone's connections and liberties, we must know about its neighbors.\n\n## Representing The Stone\n\nWe are storing the state of the game in an array where stones are represented by integers:\n\n```py\nb.state\n```\n```\narray([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 1, 2, 1, 0, 0, 0],\n       [0, 0, 0, 2, 2, 1, 0, 0, 0],\n       [0, 0, 0, 1, 2, 1, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n```\n\nKnowing that every stone is greater than zero, we can get the location of each stone on the board based on the board state:\n\n```py\nfor i, j in list(zip(*np.where(b.state > 0))):\n    print(b.state[i, j], (i, j))\n```\n```\n1 (2, 4)\n1 (3, 3)\n2 (3, 4)\n1 (3, 5)\n2 (4, 3)\n2 (4, 4)\n1 (4, 5)\n1 (5, 3)\n2 (5, 4)\n1 (5, 5)\n1 (6, 4)\n```\n\nStarting with the first stone in the list, we only care about the orthogonal locations:\n\n```py\nlocation = np.array((2, 4))\nneighbor_locs = np.array(((0, 1), (1, 0), (0, -1), (-1, 0))) + location\n```\n\nThe stones in our example are safe, but we have to account for stones along the edges which would have neighboring spaces outside the bounds of the board:\n\n```py\noob = (neighbor_locs < 0) | (neighbor_locs >= b.size)\nneighbor_locs = neighbor_locs[~oob.any(axis=1)]\nneighbor_vals = b.state[neighbor_locs[:, 0], neighbor_locs[:, 1]]\n```\n\nWith this information we can retrieve the value of each neighbor, which will tell us if it is a connection with a friendly or enemy stone, or an open liberty.\n\nThis stone has three liberties:\n\n```py\nneighbor_locs[neighbor_vals < 1]\n```\n```\narray([[2, 5],\n       [2, 3],\n       [1, 4]])\n```\n\nAnd zero friendly connections:\n\n```py\nneighbor_locs[neighbor_vals == b.state[*location]]\n```\n```\narray([], shape=(0, 2), dtype=int64)\n```\n\nFinally, we can package this into a convenient `Stone` class:\n\n```py\nclass Stone:\n    \"\"\"Representation of a Go stone\n\n    Parameters\n    ----------\n    board : Board\n        the Board object on which the stone is played\n    color : int\n        the color/player of the stone\n        1 for black, 2 for white\n    location : np.array\n        x, y location of the stone on the board\n    \"\"\"\n\n    def __init__(self, board: Board, color: int, location: np.ndarray) -> None:\n        self.board = board\n        self.color = color  # 1 is black, 2 is white\n        self.location = location\n\n    @property\n    def neighbors(self) -> tuple:\n        \"\"\"Determines the locations and values corresponding to\n        each space neighboring this stone\n\n        Returns\n        -------\n        tuple containing an array of locations and an array of values of neighbors\n        \"\"\"\n        neighbor_locs = np.array(((0, 1), (1, 0), (0, -1), (-1, 0))) + self.location\n        oob = (neighbor_locs < 0) | (neighbor_locs >= self.board.size)\n        neighbor_locs = neighbor_locs[~oob.any(axis=1)]\n        neighbor_vals = self.board.state[neighbor_locs[:, 0], neighbor_locs[:, 1]]\n\n        return neighbor_locs, neighbor_vals\n\n    @property\n    def connections(self) -> list:\n        \"\"\"Stone's friendly connections\n\n        Returns\n        -------\n        the locations of each friendly connection on the board\n        \"\"\"\n        locs, vals = self.neighbors\n        return locs[vals == self.color]\n\n    @property\n    def liberties(self) -> set:\n        \"\"\"Stone's liberties\n\n        Returns\n        -------\n        the locations of each open liberty on the board\n        \"\"\"\n        locs, vals = self.neighbors\n        return set(map(tuple, locs[vals < 1]))\n\n    def __int__(self) -> int:\n        return self.color\n\n    def __index__(self) -> int:\n        return self.color\n\n    def __hash__(self) -> int:\n        y, x = self.location\n        return hash(f'{x}{y}')\n\n    def __gt__(self, other) -> bool:\n        return self.color > other\n\n    def __lt__(self, other) -> bool:\n        return self.color < other\n\n    def __eq__(self, other) -> bool:\n        return self.color == other\n\n    def __str__(self) -> str:\n        return f'{(B, W)[self.color-1]} {self.location}'\n\n    def __repr__(self) -> str:\n        return f'Stone(Board, {self.color}, {self.location})'\n```\n\nWith this structure, each stone can now tell us about its connections, liberties, and neighbors. We are going to begin putting `Stone` objects directly into the board's state instead of just integers. For this to work, a `Stone` has to have a few specific properties:\n\n1. The stone must behave like an integer in certain situations\n    - The integer represents which player the stone belongs to (1 or 2)\n    - This allows the stone to:\n        1. Be compared with one another to determine if the stones are friendly\n        1. Be used as a list index\n1. Each stone must be a unique (hashable) object\n    - Objects must be hashable to be used in a set, which we will need shortly for finding connected groups of stones\n    - By default, python does this with `__eq__`\n    - We are using `__eq__` for determining a stone's player/color\n    - To resolve, we must implement `__hash__`*\n\nTo this end, we'll implement a series of _magic methods_* in addition to the `.neighbors()`, `.connections()`, and `.liberties()` methods we just developed.\n\n::: {.callout-tip collapse=\"true\"}\n## *Read More About Magic Methods\n\n\"Magic methods\" are also known as *dunder* methods, for their surrounding ***d***ouble ***under***scores. If you'd like a deeper understanding of how they work, I found this wonderful guide by `rszalski` on GitHub: [rszalski.github.io/magicmethods](https://rszalski.github.io/magicmethods/)\n\nHere's the tl;dr for the ones used in our `Stone` class so far:\n\n- These methods allow our stones to behave like integers when appropriate, while still being recognized as individual stones\n    - `__int__`: determines what happens when coerced into an integer, ie: `int(Stone(...))`\n    - `__index__`: determines what happens when used as a list index, ie: `some_list[Stone(...)]`\n    - `__hash__`: allows Stone objects that are \"equal\" (ie owned by the same player) to be differentiated from one another. this makes the objects \"hashable\"\n        - the important unique information about a stone on the board is its location; we'll use each stone's `x` and `y` values to create its hash\n\n- Comparison methods allow the object to be used with logical operators (further allowing them to behave like integers)\n    - `__gt__`: greater than comparison, eg: `Stone > 1` (the stone belongs to player 2)\n    - `__lt__`: less than comparison, eg: `Stone < 2` (the stone belongs to player 1)\n    - `__eq__`: equality comparison, eg: `Stone == Stone` (stones belong to the same player)\n\n- Other commonly used methods\n    - `__init__`: runs automatically whenever a new instance of the class is created\n    - `__str__`: determines what happens when coerced into a string, ie: `str(Stone(...))` or `print(Stone(...))`\n    - `__repr__`: similar to `__str__`; read the guide above for more info!\n:::\n\nWe'll also add two new methods to the `Board` class to return our `Stone` objects (we will need to get stones by player later on), and edit the existing `.play()` method to add a stone instead of an integer to the board:\n\n```py\nclass Board:\n    ...\n    def get_stones(self, player: int|None = None) -> np.ndarray:\n        if player is not None:\n            return self.state[self.state == player]\n        return self.state[self.state > 0]\n\n    @property\n    def stones(self) -> np.ndarray:\n        return self.get_stones()\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = Stone(self, player, np.array((y, x)))\n        self.move += 1\n    ...\n```\n\nAnd then we can easily access our list of stones from the board object!\n\n```py\nb.stones\n```\n```\n[Stone(Board, 1, [2 4]),\n Stone(Board, 1, [3 3]),\n Stone(Board, 2, [3 4]),\n Stone(Board, 1, [3 5]),\n Stone(Board, 2, [4 3]),\n Stone(Board, 2, [4 4]),\n Stone(Board, 1, [4 5]),\n Stone(Board, 1, [5 3]),\n Stone(Board, 2, [5 4]),\n Stone(Board, 1, [5 5]),\n Stone(Board, 1, [6 4])]\n```\n\n## It's A Beautiful Day In The Neighborhood\n\nNow that each stone can tell us who its neighbors are, we effectively have a graph which can be recursively searched to identify groups of stones. Depth-first search is marginally simpler than breadth-first, not requiring a queue:\n\n```py\ndef recursive_find_group(stone, group=None) -> set|None:\n    group = set() if group is None else group\n    if stone in group:                          # <1>\n        return\n    group.add(stone)                            # <2>\n    for con in stone.connections:               # <3>\n        recursive_find_group(con, group)\n    return group\n```\n1. Base case: return if the stone has already been seen\n2. Add the stone to the group\n3. Repeat this process for each of the stone's connections\n\nAs we saw earlier, the stone we have been using `[2, 4]` does not have any friendly neighbors and is therefore a \"group\" of 1 stone. We can instead choose one of white's stones, `[4, 3]`, as the starting stone from which to find a larger group.\n\n```py\nstarting_stone = b.stones[4]  # white stone, located [4, 3]\nresult = recursive_find_group(starting_stone)\nprint(result)\n```\n```\n{Stone(Board, 2, [4 5]),\n Stone(Board, 2, [4 3]),\n Stone(Board, 2, [3 4]),\n Stone(Board, 2, [4 4])}\n```\n\nThese are the stones we are looking for. Now let's try to get every group on the board. There is a single white group of four stones, and 5 black groups; one with three stones, and four with one stone each. We should see six total groups:\n\n```py\ngroups = []\nstones = set(b.get_stones())\nwhile stones:\n    group = recursive_find_group(stones.pop())\n    groups.append(group)\n    stones = stones - group\n\nprint('Total # of groups:', len(groups))\n```\n```\nTotal # of groups: 6\n```\n\nPerfect!\n\n# Re: Capturing\n\nIf you recall from earlier, a stone or group of stones is captured when all of its liberties (empty adjacent spaces) are filled by the opponent. Each stone in our groups also knows about its liberties, so we can easily get the total liberties of a group.\n\nThe first group in the list we created above is the black group of 3 on the right side of the board. It should have 5 total liberties:\n\n```py\ngroup = groups[0]\nliberties = len(set.union(*[s.liberties for s in group]))\n\nprint('Total liberties:', liberties)\n```\n```\nTotal liberties: 5\n```\n\nThe third group in our list is the white group. This group has one liberty, but if we play another black stone at `2, 4` (C5) it will have zero:\n\n```py\nb.play(1, 2, 4)\n\ngroup = groups[2]\nliberties = len(set.union(*[s.liberties for s in group]))\n\nprint('Total liberties:', liberties)\n```\n```\nTotal liberties: 0\n```\n\nAt which point it should be removed from the board:\n\n```py\nif liberties == 0:\n    remove = np.array([s.location for s in group])\n    b.state[remove[:, 0], remove[:, 1]] = 0\n\nprint(b)\n```\n\n<img src='./images/capture1.png' />\n\n## Putting It Together\n\nNow we can add a new class method `.process_stones()` to the board which will remove captured groups. We'll also further edit the `.play()` method because we want to check for captured groups on each play:\n\n```py\nclass Board:\n    ...\n    def process_groups(self) -> None:\n        \"\"\"Find groups of stones and remove those with no liberties\"\"\"\n\n        def recursive_find_group(stone, group=None) -> set:\n            \"\"\"Recursively find groups of stones\n\n            Parameters\n            ----------\n            stone\n                a stone to be added to the group\n            group\n                the current group of stones\n            Returns\n            -------\n            a unique set of the stones in a group with the starting stone\n            \"\"\"\n\n            group = set() if group is None else group\n            if stone in group:\n                return set()\n            group.add(stone)\n            for con in stone.connections:\n                recursive_find_group(con, group)\n            return group\n\n        groups = []\n        stones = set(self.get_stones())\n        while stones:\n            group = recursive_find_group(stones.pop())\n            groups.append(group)\n            stones = stones - group\n\n            liberties = len(set.union(*[s.liberties for s in group]))\n            if liberties == 0:\n                remove = np.array([s.location for s in group])\n                self.state[remove[:, 0], remove[:, 1]] = 0\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = Stone(self, player, np.array((y, x)))\n        self.process_groups()\n        self.move += 1\n    ...\n```\n\nLet's take another look at our simple example from the beginning:\n\n```py\nb = Board(9, debug=True)\nplays = [\n    (1, 3, 4), (2, 4, 4),\n    (1, 4, 3), (2, 5, 3),\n    (1, 4, 5), (2, 5, 5),\n    (1, 5, 4)\n]\n\nfor player, x, y in plays:\n    b.play(player, x, y)\n    sleep(1)\n    print(b)\n```\n\n<img src='./images/successfulcapture1.gif' />\n\nBeautiful! Next, let's try to play a full game.\n\n# Playing The Game\n\nAs mentioned at the beginning, [last episode](https://sweep.sh/posts/2024-10-28-go-in-python-2/#smart-game-format) we also wrote some code to retrieve Smart Game Format game data from [OGS](https://online-go.com) and parse the results. Here, we'll turn these steps into a pair of functions:\n\n```py\nimport os\nimport requests\n\nBASE_URL = \"https://online-go.com/api/v1/games\"\n\n\ndef retrieve_sgf(game_url: str) -> str:                                 # <1>\n    \"\"\"Retrieve the SGF text from the given game url or id\n\n    Parameters\n    ----------\n    game_url\n        the url or game id of an OGS game\n\n    Returns\n    -------\n    the Smart Game Format text data for the given game\n    \"\"\"\n\n    game_id = game_url.strip(\"https://online-go.com/game/\")             # <2>\n    request_url = os.path.join(BASE_URL, game_id, 'sgf')\n\n    r = requests.get(request_url)\n    return r.content.decode('utf-8')\n\ndef read_sgf(sgf: str) -> tuple:                                        # <3>\n    \"\"\"Parse a Smart Game Format file into metadata and game moves\n\n    Parameters\n    ----------\n    sgf\n        string data of the SGF file\n\n    Returns\n    -------\n    a tuple containing metadata and game moves\n    \"\"\"\n\n    text = sgf.strip(')').split(';')\n    meta = dict(re.findall(r'(\\w+)\\[(.*?)\\]\\n?', text[1]))\n    moves = [tuple(m.strip('\\n()]').split('[')) for m in text[2:]]\n\n    return meta, moves\n```\n1. `retrieve_sgf()` gets SGF data from an OGS game. This is specific to OGS, so it is kept separate from `read_sgf()`.\n2. I want the function to be able to take a game ID or a full link to the game. Here we strip the url off of the game ID if it exists, then build an API url to make the request.\n3. `read_sgf()` parses metadata and game moves out of an SGF string. In the future, we could get SGF files from different sources, so this is kept separate from `retrieve_sgf()`\n\n```py\ngame = \"https://online-go.com/game/68039230\"\nsgf = retrieve_sgf(game)\nmeta, moves = read_sgf(sgf)\n\nsize = int(meta['SZ'])\n\nprint('Board size:', size)\nprint('# of moves:', len(moves))\nprint('Result:', meta['RE'])\nprint('\\nMoves:\\n', moves)\n```\n```\nBoard size: 13\n# of moves: 100\nResult: B+26.5\n\nMoves:\n[('B', 'gg'),\n ('W', 'kc'),\n ('B', 'ji'),\n\n ...\n\n ('W', 'cj'),\n ('B', ''),\n ('W', '')]\n```\n\nFrom the SGF, we can see that game number 68039230 was played on a 13x13 board to 100 moves. It ended with a mutual pass and Black won by 26.5 points. Let's watch:\n\n```py\nb = Board(size)\nfor player, move in moves:\n    player = 'BW'.index(player) + 1\n\n    if move:  # an empty move is a pass\n        x, y = (ALPHA.index(c) for c in move)\n\n        b.play(player, x, y)\n        print(b)\n        sleep(0.15)\n```\n<figure>\n    <img src='./images/fullgame1.gif' />\n    <figcaption><i>Result: B+26.5</i></figcaption>\n</figure>\n\n## Wrap It Up\n\nWith that, I think it would be useful to abstract the idea of getting moves from an OGS game and playing them on the board:\n\n```py\nfrom typing import Generator\n\nclass OGSGame:\n    BASE_URL = \"https://online-go.com/api/v1/games/\"\n\n    def __init__(self, game_url: str) -> None:\n        self.id = game_url.strip(\"https://online-go.com/game/\")\n        self.url = self.BASE_URL + self.id\n        self.sgf = self.retrieve_sgf()\n        self.meta, self.moves = read_sgf(self.sgf)\n        self.board = Board(int(self.meta['SZ']))\n\n    @property\n    def data(self) -> dict:\n        return requests.get(self.url).json()\n\n    @property\n    def turns(self) -> Generator:\n        yield self.board\n        for player, move in self.moves:\n            player = 'BW'.index(player) + 1\n\n            if move:\n                x, y = (ALPHA.index(c) for c in move)\n                self.board.play(player, x, y)\n\n            yield self.board\n\n    def retrieve_sgf(self) -> str:\n        text = requests.get(self.url + '/sgf').text\n        if text == 'Permission denied':\n            raise ValueError('Cannot access private game')\n\n        return text\n```\n```\n\n```\n\nIt's probably unnecessary to make `turns` a generator, but it's probably also unnecessary to have the `Board` object render itself. A problem(s) for another day. :)\n\n\n- Part 4?\n    - vhs\n        - nixos\n        - docker\n    - plotly\n    - discord\n    - docker\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.33","resources":["../../CNAME"],"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Go in Python, Part 3","description":"This Is Still Not An Article About Golang","author":"n sweep","date":"yyyy-mm-dd","categories":["go","baduk","python","programming"],"draft":true},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}
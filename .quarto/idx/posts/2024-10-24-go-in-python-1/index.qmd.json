{"title":"Go in Python, Part 1","markdown":{"yaml":{"title":"Go in Python, Part 1","description":"This Is Not An Article About Golang","author":"n sweep","date":"2024-10-24","categories":["go","baduk","python","programming"]},"headingText":"Game Engine","containsRefs":false,"markdown":"\n\nA few months ago I started playing [Go](https://en.wikipedia.org/wiki/Go_(game)) and became a fast fan of the game. I and a few friends I have roped into learning with me have been playing on [online-go.com (OGS)](https://online-go.com), both via their website and a third party Android app called [Sente](https://play.google.com/store/apps/details?id=io.zenandroid.onlinego&hl=en_US). As with every new website I find remotely useful, I had to check if they have an [API](https://en.wikipedia.org/wiki/Web_API).\n\nSpoiler: they do.\n\n<figure>\n    <a href='https://en.wikipedia.org/wiki/Go_(game)#'><img src=\"./images/Zhou_Wenju_Palace_Museum_Detail_of_Go_Players.jpg\" width=600px /></a>\n    <figcaption><i>Li Jing playing Go with his brothers. Detail from a painting by Zhou Wenju (fl. 942–961 CE), Southern Tang dynasty. [Wikipedia]</i></figcaption>\n</figure>\n\n\n\nMy goal is to make a program that, given the link to or ID of a game on OGS, will produce an animated gif of the game. Comfortable in my knowledge that OGS has an API and [charmbracelet/vhs](https://github.com/charmbracelet/vhs) exists, I chose to start with the game engine. This could be later categorized as a mistake.\n\n\n\nAs I intend to use [charmbracelet/vhs](https://github.com/charmbracelet/vhs) to generate the gif, my first concern was whether I can represent a Go board in a nice way in the terminal. The game pieces in Go are black and white stones and I already know I want to use emoji (⚫⚪) to represent them. There are plenty of [Unicode characters](https://symbl.cc/en/unicode/blocks/box-drawing/) for drawing boxes and grids, but the trouble is that emoji are roughly two characters wide in monospace fonts. With this limitation, a grid of intersecting lines was impossible, but I eventually came up with the following ASCII board:\n\n```\n   A B C D E F G H J K L M N O P Q R S T\n19 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 19\n18 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 18\n17 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 17\n16 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 16\n15 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 15\n14 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 14\n13 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 13\n12 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 12\n11 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 11\n10 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 10\n 9 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 9\n 8 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 8\n 7 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 7\n 6 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 6\n 5 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 5\n 4 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 4\n 3 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 3\n 2 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 2\n 1 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 1\n   A B C D E F G H J K L M N O P Q R S T\n```\n\nNote: This board mimics the default board display on OGS, which omits the letter I from the legend.\n\n## Representing the Board\n\nConsidering that the board is simply a 2d array, `numpy` is the perfect choice for representing the game's state. Zeros are empty spaces, ones will be black stones, and twos will be white stones. Let's start with some constants and a board.\n\n```py\nimport numpy as np\n\n# let's start with a 9x9 board for the sake of brevity\nsize = 9\nstate = np.zeros((size,size), dtype=int)\nstate[4, 4] = 1\nstate[2, 3] = 2\nprint(state)\n```\n\n```\narray([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 2, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n```\n\n### Game Pieces & Intersections\n\nNow we can loop over the game state to make a friendlier render of the game. Default monospace fonts in browsers are often a bit tall and narrow - if this looks a little awkward, there are screenshots coming up.\n\n```py\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\n\nfor row in state:\n    print(''.join([(PT,B,W)[i] for i in row]))\n```\n\n```\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴⚪╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n```\n\n### Adding Star Points to the Board\n\nStar points have no value or significance in Go, they are simply there to orient ourselves on the board. It just doesn't look quite right without them though.\n\nI wrote this in a fever dream. Through liberal use of the walrus operator, we set the location of each star point to a -1. By creating an array the same size as our game board, we'll be able to combine them.\n\nTo be more specific, `corners` calculates the spacing between star points based on the size of the board (13 and 19 size boards have the same spacing), then we use `product()` to give us every combination of appropriate points on the board, adding in the middle point manually.\n\n```py\nfrom itertools import product\n\nstar_points = np.zeros((size,size), dtype=int)\ncorners = [j for i in range(3) if (j:=((s:=2+(size>9))+(2*s*i))) < size]\npts = [(f:=size//2, f)] + list(product(corners, repeat=2))\nstar_points[*zip(*pts)] = -1\n\nprint(star_points)\n```\n\nWhy -1? The way things are written so far, a 3 would also work. I wanted the ability to get all stones on the board by filtering the state for any positions that are greater than zero, however I inadvertently skirted this problem by only applying the star points to the board directly before printing and the -1 stuck around.\n\n```\narray([[ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0, -1,  0,  0,  0, -1,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0, -1,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0, -1,  0,  0,  0, -1,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0]])\n```\n\n\"Masking\" is a useful technique where we create an array of boolean values of the same `shape` as an array of data. The array of booleans, or 'mask', can then be applied to the array of data by indexing: `data[mask]`. This allows us to return or affect only the values that align with `True` values in the mask.\n\nBy masking out the game pieces that have already been played (any points that are not 0), we can assign the star points to the game board only if a piece hasn't already been played in that position.\n\n```py\nSP = \"╺╸\"\n\n# make a copy before applying the star points; we don't want our game state to\n# contain anything other than zeros, ones, and twos\nboard = state.copy()\nmask = ~state.astype(bool)\nboard[mask] = star_points[mask]\n\nfor row in board:\n    print(''.join([(PT,B,W,SP)[i] for i in row]))\n```\n\n```\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╺╸⚪╶╴╶╴╺╸╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╺╸╶╴╶╴╶╴╺╸╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n```\n\n### Labelling the Rows & Columns\n\nNext up are row and column labels. As mentioned above, OGS skips the letter I, so I am doing the same.\n\n```py\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\njoined = ' '.join(list(ALPHA.replace('i', '')[:size])).upper()\nrows = [col_label:=f\"{(d:=' ' * s)}{joined} {d}\"]\n\nfor r, input_row in enumerate(board, 1):\n    row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n    num = str(size - r + 1)\n    lnum = num.rjust(int(len(str(size))))\n    rnum = num.ljust(int(len(str(size))))\n    rows.append(f'{lnum} {row} {rnum}')\n\nrows.append(col_label)\n\nprint('\\n'.join(rows))\n```\n```\n--A B C D E F G H J --\n9 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 9\n8 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 8\n7 ╶╴╶╴╺╸⚪╶╴╶╴╺╸╶╴╶╴ 7\n6 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 6\n5 ╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴ 5\n4 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 4\n3 ╶╴╶╴╺╸╶╴╶╴╶╴╺╸╶╴╶╴ 3\n2 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 2\n1 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 1\n--A B C D E F G H J --\n```\n\n### A Coat of Paint\n\nLet's add some [ANSI color escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors) to the mix to give our board that realistic wooden effect.\n\n```py\nBLACK = '\\033[30m'\nGRAY = '\\033[90m'\nYELLOW = '\\033[33m'\nBG_YELLOW = '\\033[43m'\nRESET = '\\033[0m'\n\n\njoined = ' '.join(list(ALPHA.replace('i', '')[:size])).upper()\nrows = [col_label:=f\"{YELLOW}{(d:=' ' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\nfor r, input_row in enumerate(board, 1):\n    row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n    num = str(size - r + 1)\n    lnum = num.rjust(int(len(str(size))))\n    rnum = num.ljust(int(len(str(size))))\n    rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\nrows.append(col_label)\nrows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\nprint('\\n'.join(rows))\n```\n\nMarkdown doesn't render color escape codes, so here's a screenshot!\n\n<img src=\"./images/9x9.png\" />\n\n## Wrap It Up\n\nNow let's package that all together in a class to make it easier to play a stone.\n\n```py\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\nSP = \"╺╸\"\n\nBLACK = '\\033[30m'\nGRAY = '\\033[90m'\nYELLOW = '\\033[33m'\nBG_YELLOW = '\\033[43m'\nRESET = '\\033[0m'\n\n\nclass Board:\n    def __init__(self, size: int = 19) -> None:\n        self.size = size\n        self.state = np.zeros((size,size), dtype=int)\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y][x] = player\n\n    def plaintext_board(self) -> str:\n        star_points = np.zeros((self.size,self.size), dtype=int)\n        corners = [j for i in range(3) if (j:=((s:=2+(self.size>9))+(2*s*i))) < self.size]\n        pts = [(f:=self.size//2, f)] + list(product(corners, repeat=2))\n        star_points[*zip(*pts)] = -1\n\n        board = self.state.copy()\n        mask = ~self.state.astype(bool)\n        board[mask] = star_points[mask]\n\n        joined = ' '.join(list(ALPHA.replace('i', '')[:self.size])).upper()\n        rows = [col_label:=f\"{YELLOW}{(d:='-' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\n        for r, input_row in enumerate(board, 1):\n            row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n            num = str(self.size - r + 1)\n            lnum = num.rjust(int(len(str(self.size))))\n            rnum = num.ljust(int(len(str(self.size))))\n            rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\n        rows.append(col_label)\n        rows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\n        return '\\n'.join(rows)\n\n    def __str__(self) -> str:\n        return self.plaintext_board()\n```\n\n### The `.__str__()` method\n\nPython class method surrounded in double underscores are called \"magic methods\" or \"dunder methods\". `.__init__()` is also an example. [Read more about them](https://duckduckgo.com/?q=python+magic+methods).\n\ntl;dr, the [`__str__()` method](https://docs.python.org/3/reference/datamodel.html#object.__str__) determines what gets sent to the console when an instance of the class is given as an argument to `print()`, allowing us to simply print a board like so:\n\n```py\nb = Board(9)\nprint(b)\n```\n\n### The `.play()` method\n\nWe've swapped `x` and `y` in the input arguments to be more intuitive. All we have to do is add a player number (1 for black, 2 for white) to the game's state and the appropriate pieces will be rendered on print.\n\n```py\n    ...\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = player\n    ...\n```\n\n## Quick Test Drive\n\nTesting the `play` method on a board of each size:\n\n```py\nfor size in [9, 13, 19]:\n    b = Board(size)\n    b.play(1, 4, 4)\n    b.play(2, 3, 2)\n    print(b)\n```\n\n<img src=\"./images/all_3.png\" />\n\nNice.\n\n# Next Time: API Headaches\n\nWhile there is more to do with regard to the game engine, it would be great to have a list of plays to loop over with our new `Board` class, and that's exactly what the OGS API returns. Next up, we'll talk about the first time I almost gave up on this project, and also a lot of documentation.\n\nUntil then!\n\n[Read part 2](../2024-10-28-go-in-python-2/index.qmd)\n","srcMarkdownNoYaml":"\n\nA few months ago I started playing [Go](https://en.wikipedia.org/wiki/Go_(game)) and became a fast fan of the game. I and a few friends I have roped into learning with me have been playing on [online-go.com (OGS)](https://online-go.com), both via their website and a third party Android app called [Sente](https://play.google.com/store/apps/details?id=io.zenandroid.onlinego&hl=en_US). As with every new website I find remotely useful, I had to check if they have an [API](https://en.wikipedia.org/wiki/Web_API).\n\nSpoiler: they do.\n\n<figure>\n    <a href='https://en.wikipedia.org/wiki/Go_(game)#'><img src=\"./images/Zhou_Wenju_Palace_Museum_Detail_of_Go_Players.jpg\" width=600px /></a>\n    <figcaption><i>Li Jing playing Go with his brothers. Detail from a painting by Zhou Wenju (fl. 942–961 CE), Southern Tang dynasty. [Wikipedia]</i></figcaption>\n</figure>\n\n\n\nMy goal is to make a program that, given the link to or ID of a game on OGS, will produce an animated gif of the game. Comfortable in my knowledge that OGS has an API and [charmbracelet/vhs](https://github.com/charmbracelet/vhs) exists, I chose to start with the game engine. This could be later categorized as a mistake.\n\n\n# Game Engine\n\nAs I intend to use [charmbracelet/vhs](https://github.com/charmbracelet/vhs) to generate the gif, my first concern was whether I can represent a Go board in a nice way in the terminal. The game pieces in Go are black and white stones and I already know I want to use emoji (⚫⚪) to represent them. There are plenty of [Unicode characters](https://symbl.cc/en/unicode/blocks/box-drawing/) for drawing boxes and grids, but the trouble is that emoji are roughly two characters wide in monospace fonts. With this limitation, a grid of intersecting lines was impossible, but I eventually came up with the following ASCII board:\n\n```\n   A B C D E F G H J K L M N O P Q R S T\n19 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 19\n18 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 18\n17 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 17\n16 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 16\n15 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 15\n14 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 14\n13 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 13\n12 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 12\n11 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 11\n10 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 10\n 9 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 9\n 8 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 8\n 7 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 7\n 6 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 6\n 5 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 5\n 4 ╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴╶╴╶╴╺╸╶╴╶╴╶╴ 4\n 3 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 3\n 2 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 2\n 1 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 1\n   A B C D E F G H J K L M N O P Q R S T\n```\n\nNote: This board mimics the default board display on OGS, which omits the letter I from the legend.\n\n## Representing the Board\n\nConsidering that the board is simply a 2d array, `numpy` is the perfect choice for representing the game's state. Zeros are empty spaces, ones will be black stones, and twos will be white stones. Let's start with some constants and a board.\n\n```py\nimport numpy as np\n\n# let's start with a 9x9 board for the sake of brevity\nsize = 9\nstate = np.zeros((size,size), dtype=int)\nstate[4, 4] = 1\nstate[2, 3] = 2\nprint(state)\n```\n\n```\narray([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 2, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n```\n\n### Game Pieces & Intersections\n\nNow we can loop over the game state to make a friendlier render of the game. Default monospace fonts in browsers are often a bit tall and narrow - if this looks a little awkward, there are screenshots coming up.\n\n```py\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\n\nfor row in state:\n    print(''.join([(PT,B,W)[i] for i in row]))\n```\n\n```\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴⚪╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n```\n\n### Adding Star Points to the Board\n\nStar points have no value or significance in Go, they are simply there to orient ourselves on the board. It just doesn't look quite right without them though.\n\nI wrote this in a fever dream. Through liberal use of the walrus operator, we set the location of each star point to a -1. By creating an array the same size as our game board, we'll be able to combine them.\n\nTo be more specific, `corners` calculates the spacing between star points based on the size of the board (13 and 19 size boards have the same spacing), then we use `product()` to give us every combination of appropriate points on the board, adding in the middle point manually.\n\n```py\nfrom itertools import product\n\nstar_points = np.zeros((size,size), dtype=int)\ncorners = [j for i in range(3) if (j:=((s:=2+(size>9))+(2*s*i))) < size]\npts = [(f:=size//2, f)] + list(product(corners, repeat=2))\nstar_points[*zip(*pts)] = -1\n\nprint(star_points)\n```\n\nWhy -1? The way things are written so far, a 3 would also work. I wanted the ability to get all stones on the board by filtering the state for any positions that are greater than zero, however I inadvertently skirted this problem by only applying the star points to the board directly before printing and the -1 stuck around.\n\n```\narray([[ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0, -1,  0,  0,  0, -1,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0, -1,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0, -1,  0,  0,  0, -1,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0]])\n```\n\n\"Masking\" is a useful technique where we create an array of boolean values of the same `shape` as an array of data. The array of booleans, or 'mask', can then be applied to the array of data by indexing: `data[mask]`. This allows us to return or affect only the values that align with `True` values in the mask.\n\nBy masking out the game pieces that have already been played (any points that are not 0), we can assign the star points to the game board only if a piece hasn't already been played in that position.\n\n```py\nSP = \"╺╸\"\n\n# make a copy before applying the star points; we don't want our game state to\n# contain anything other than zeros, ones, and twos\nboard = state.copy()\nmask = ~state.astype(bool)\nboard[mask] = star_points[mask]\n\nfor row in board:\n    print(''.join([(PT,B,W,SP)[i] for i in row]))\n```\n\n```\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╺╸⚪╶╴╶╴╺╸╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╺╸╶╴╶╴╶╴╺╸╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴\n```\n\n### Labelling the Rows & Columns\n\nNext up are row and column labels. As mentioned above, OGS skips the letter I, so I am doing the same.\n\n```py\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\njoined = ' '.join(list(ALPHA.replace('i', '')[:size])).upper()\nrows = [col_label:=f\"{(d:=' ' * s)}{joined} {d}\"]\n\nfor r, input_row in enumerate(board, 1):\n    row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n    num = str(size - r + 1)\n    lnum = num.rjust(int(len(str(size))))\n    rnum = num.ljust(int(len(str(size))))\n    rows.append(f'{lnum} {row} {rnum}')\n\nrows.append(col_label)\n\nprint('\\n'.join(rows))\n```\n```\n--A B C D E F G H J --\n9 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 9\n8 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 8\n7 ╶╴╶╴╺╸⚪╶╴╶╴╺╸╶╴╶╴ 7\n6 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 6\n5 ╶╴╶╴╶╴╶╴⚫╶╴╶╴╶╴╶╴ 5\n4 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 4\n3 ╶╴╶╴╺╸╶╴╶╴╶╴╺╸╶╴╶╴ 3\n2 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 2\n1 ╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴╶╴ 1\n--A B C D E F G H J --\n```\n\n### A Coat of Paint\n\nLet's add some [ANSI color escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors) to the mix to give our board that realistic wooden effect.\n\n```py\nBLACK = '\\033[30m'\nGRAY = '\\033[90m'\nYELLOW = '\\033[33m'\nBG_YELLOW = '\\033[43m'\nRESET = '\\033[0m'\n\n\njoined = ' '.join(list(ALPHA.replace('i', '')[:size])).upper()\nrows = [col_label:=f\"{YELLOW}{(d:=' ' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\nfor r, input_row in enumerate(board, 1):\n    row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n    num = str(size - r + 1)\n    lnum = num.rjust(int(len(str(size))))\n    rnum = num.ljust(int(len(str(size))))\n    rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\nrows.append(col_label)\nrows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\nprint('\\n'.join(rows))\n```\n\nMarkdown doesn't render color escape codes, so here's a screenshot!\n\n<img src=\"./images/9x9.png\" />\n\n## Wrap It Up\n\nNow let's package that all together in a class to make it easier to play a stone.\n\n```py\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\nB = \"⚫\"\nW = \"⚪\"\nPT = \"╶╴\"\nSP = \"╺╸\"\n\nBLACK = '\\033[30m'\nGRAY = '\\033[90m'\nYELLOW = '\\033[33m'\nBG_YELLOW = '\\033[43m'\nRESET = '\\033[0m'\n\n\nclass Board:\n    def __init__(self, size: int = 19) -> None:\n        self.size = size\n        self.state = np.zeros((size,size), dtype=int)\n\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y][x] = player\n\n    def plaintext_board(self) -> str:\n        star_points = np.zeros((self.size,self.size), dtype=int)\n        corners = [j for i in range(3) if (j:=((s:=2+(self.size>9))+(2*s*i))) < self.size]\n        pts = [(f:=self.size//2, f)] + list(product(corners, repeat=2))\n        star_points[*zip(*pts)] = -1\n\n        board = self.state.copy()\n        mask = ~self.state.astype(bool)\n        board[mask] = star_points[mask]\n\n        joined = ' '.join(list(ALPHA.replace('i', '')[:self.size])).upper()\n        rows = [col_label:=f\"{YELLOW}{(d:='-' * s)}{BLACK}{joined} {YELLOW}{d}\"]\n\n        for r, input_row in enumerate(board, 1):\n            row = ''.join([(PT,B,W,SP)[i] for i in input_row])\n            num = str(self.size - r + 1)\n            lnum = num.rjust(int(len(str(self.size))))\n            rnum = num.ljust(int(len(str(self.size))))\n            rows.append(f'{BLACK}{lnum} {GRAY}{row} {BLACK}{rnum}')\n\n        rows.append(col_label)\n        rows = [f'{BG_YELLOW}{row}{RESET}' for row in rows]\n\n        return '\\n'.join(rows)\n\n    def __str__(self) -> str:\n        return self.plaintext_board()\n```\n\n### The `.__str__()` method\n\nPython class method surrounded in double underscores are called \"magic methods\" or \"dunder methods\". `.__init__()` is also an example. [Read more about them](https://duckduckgo.com/?q=python+magic+methods).\n\ntl;dr, the [`__str__()` method](https://docs.python.org/3/reference/datamodel.html#object.__str__) determines what gets sent to the console when an instance of the class is given as an argument to `print()`, allowing us to simply print a board like so:\n\n```py\nb = Board(9)\nprint(b)\n```\n\n### The `.play()` method\n\nWe've swapped `x` and `y` in the input arguments to be more intuitive. All we have to do is add a player number (1 for black, 2 for white) to the game's state and the appropriate pieces will be rendered on print.\n\n```py\n    ...\n    def play(self, player: int, x: int, y: int) -> None:\n        self.state[y, x] = player\n    ...\n```\n\n## Quick Test Drive\n\nTesting the `play` method on a board of each size:\n\n```py\nfor size in [9, 13, 19]:\n    b = Board(size)\n    b.play(1, 4, 4)\n    b.play(2, 3, 2)\n    print(b)\n```\n\n<img src=\"./images/all_3.png\" />\n\nNice.\n\n# Next Time: API Headaches\n\nWhile there is more to do with regard to the game engine, it would be great to have a list of plays to loop over with our new `Board` class, and that's exactly what the OGS API returns. Next up, we'll talk about the first time I almost gave up on this project, and also a lot of documentation.\n\nUntil then!\n\n[Read part 2](../2024-10-28-go-in-python-2/index.qmd)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.33","resources":["../../CNAME"],"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Go in Python, Part 1","description":"This Is Not An Article About Golang","author":"n sweep","date":"2024-10-24","categories":["go","baduk","python","programming"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}